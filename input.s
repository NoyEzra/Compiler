
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

section .data
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_BOOL(1)
MAKE_BOOL(0)
MAKE_LITERAL_STRING "whatever" 
MAKE_LITERAL_SYMBOL(const_tbl +6)
MAKE_LITERAL_INT(1)
MAKE_LITERAL_INT(0)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_INT(2)
MAKE_LITERAL_INT(3)
MAKE_LITERAL_PAIR(const_tbl +61, const_tbl +1)
MAKE_LITERAL_PAIR(const_tbl +52, const_tbl +70)
MAKE_LITERAL_PAIR(const_tbl +32, const_tbl +87)
MAKE_LITERAL_INT(4)
MAKE_LITERAL_INT(5)
MAKE_LITERAL_INT(6)
MAKE_LITERAL_PAIR(const_tbl +139, const_tbl +1)
MAKE_LITERAL_PAIR(const_tbl +130, const_tbl +148)
MAKE_LITERAL_PAIR(const_tbl +121, const_tbl +165)
MAKE_LITERAL_INT(7)
MAKE_LITERAL_INT(8)
MAKE_LITERAL_INT(9)
MAKE_LITERAL_PAIR(const_tbl +217, const_tbl +1)
MAKE_LITERAL_PAIR(const_tbl +208, const_tbl +226)
MAKE_LITERAL_PAIR(const_tbl +199, const_tbl +243)
MAKE_LITERAL_PAIR(const_tbl +260, const_tbl +1)
MAKE_LITERAL_PAIR(const_tbl +182, const_tbl +277)
MAKE_LITERAL_PAIR(const_tbl +104, const_tbl +294)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+4
%define SOB_TRUE_ADDRESS const_tbl+2

fvar_tbl:
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED

global main
extern memmove
section .text
main:
    push rbp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp
    mov rbp,rsp

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl+0], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl+8], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl+16], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl+24], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl+32], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl+40], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl+48], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl+56], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl+64], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl+72], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl+80], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl+88], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl+96], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl+104], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl+112], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl+120], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl+128], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl+136], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl+144], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl+152], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl+160], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl+168], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl+176], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car_asm)
    mov [fvar_tbl+184], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr_asm)
    mov [fvar_tbl+192], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons_asm)
    mov [fvar_tbl+200], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car_asm)
    mov [fvar_tbl+208], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr_asm)
    mov [fvar_tbl+216], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply_asm)
    mov [fvar_tbl+224], rax

user_code_fragment:
;;; The code you compiled will be catenated here.
;;; It will be executed immediately after the closures for
;;; the primitive procedures are set up.

 
                                       mov rax, [fvar_tbl +224]
                                       push rax 
                                       mov rax, [fvar_tbl +200]
                                       push rax 
                                       mov rax, [fvar_tbl +192]
                                       push rax 
                                       mov rax, [fvar_tbl +184]
                                       push rax 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                    push 5
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA10				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_210:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_210			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_210
                  endLoop_210:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_210:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_210
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_210
                  endLoopArgs_210:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode10)
                    jmp Lcont10
                  emptyA10:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty10
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop10:
                    cmp rax, rcx
                    je emptyA_end10
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop10
                  bothEmpty10:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode10)
                    jmp Lcont10
                  emptyA_end10:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode10)
                    jmp Lcont10
                    MAKE_CLOSURE (rbx, rax, Lcode10)
                    jmp Lcont10
                  Lcode10:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +23
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA15				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_215:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_215			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_215
                  endLoop_215:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_215:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_215
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_215
                  endLoopArgs_215:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode15)
                    jmp Lcont15
                  emptyA15:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty15
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop15:
                    cmp rax, rcx
                    je emptyA_end15
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop15
                  bothEmpty15:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode15)
                    jmp Lcont15
                  emptyA_end15:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode15)
                    jmp Lcont15
                    MAKE_CLOSURE (rbx, rax, Lcode15)
                    jmp Lcont15
                  Lcode15:
                    push rbp
                    mov rbp, rsp
                    
mov rax, qword [rbp + 8*(4 + 0)]
                                 MALLOC rcx, 8
                                 mov [rcx], rax
                                 mov rax, rcx 
                                                         mov qword [rbp + 8*(4 + 0)], rax 
                                                         mov rax, SOB_VOID_ADDRESS

 mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA26				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_226:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_226			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_226
                  endLoop_226:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_226:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_226
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_226
                  endLoopArgs_226:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode26)
                    jmp Lcont26
                  emptyA26:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty26
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop26:
                    cmp rax, rcx
                    je emptyA_end26
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop26
                  bothEmpty26:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode26)
                    jmp Lcont26
                  emptyA_end26:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode26)
                    jmp Lcont26
                  Lcode26:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 3                         ;;;cmp rbx numOfArgs
                    jge shrink26                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 40                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing26
                  shrink26:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 2                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink26:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink26
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink26
                  endLoopShrink26:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 40                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 3            ;;;newN= numArgs
                  doNothing26:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure86
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic86
                  notClosure86:
                    ;;;complete with segmentation fault
                  endApplic86: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse27 
                                            mov rax, const_tbl +1 
                                            jmp Lexit27 
                                            Lelse27: 
                                             
                                       mov rax, qword [rbp + 8*(4 + 2)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure81
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic81
                  notClosure81:
                    ;;;complete with segmentation fault
                  endApplic81: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse28 
                                             
                                        
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure66
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic66
                  notClosure66:
                    ;;;complete with segmentation fault
                  endApplic66:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure64
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic64
                  notClosure64:
                    ;;;complete with segmentation fault
                  endApplic64:
                                       push rax 
                                        
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure75
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic75
                  notClosure75:
                    ;;;complete with segmentation fault
                  endApplic75:
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*(4 + 0)]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure73
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic73
                  notClosure73:
                    ;;;complete with segmentation fault
                  endApplic73:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*3]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure62
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic62
                  notClosure62:
                    ;;;complete with segmentation fault
                  endApplic62: 
                                            jmp Lexit28 
                                            Lelse28: 
                                             
                                        
                                        
                                       mov rax, qword [rbp + 8*(4 + 2)]
                                       push rax 
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure34
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic34
                  notClosure34:
                    ;;;complete with segmentation fault
                  endApplic34:
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure40
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic40
                  notClosure40:
                    ;;;complete with segmentation fault
                  endApplic40:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, [fvar_tbl +232]
                                       push rax 
                    push 4
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*4]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure32
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic32
                  notClosure32:
                    ;;;complete with segmentation fault
                  endApplic32:
                                       push rax 
                                        
                                        
                                       mov rax, qword [rbp + 8*(4 + 2)]
                                       push rax 
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure49
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic49
                  notClosure49:
                    ;;;complete with segmentation fault
                  endApplic49:
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure55
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic55
                  notClosure55:
                    ;;;complete with segmentation fault
                  endApplic55:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 3
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*4]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure47
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic47
                  notClosure47:
                    ;;;complete with segmentation fault
                  endApplic47:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*3]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure30
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic30
                  notClosure30:
                    ;;;complete with segmentation fault
                  endApplic30: 
                                            Lexit28: 
                                            Lexit27:
                    leave
                    ret
                  Lcont26: 
                                     push rax 
                                     mov rax, qword [rbp + 8*(4 + 0)] 
                                     pop qword [rax] 
                                     mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8*(4 + 0)] 
                                  mov rax, qword [rax]
                    leave
                    ret
                  Lcont15:
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure12
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic12
                  notClosure12:
                    ;;;complete with segmentation fault
                  endApplic12:
                    leave
                    ret
                  Lcont10:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure3
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic3
                  notClosure3:
                    ;;;complete with segmentation fault
                  endApplic3:
                                                 define_lable1: 
                                                 mov qword [fvar_tbl +232], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +192]
                                       push rax 
                                       mov rax, [fvar_tbl +184]
                                       push rax 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                    push 3
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA98				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_298:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_298			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_298
                  endLoop_298:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_298:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_298
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_298
                  endLoopArgs_298:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode98)
                    jmp Lcont98
                  emptyA98:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty98
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop98:
                    cmp rax, rcx
                    je emptyA_end98
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop98
                  bothEmpty98:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode98)
                    jmp Lcont98
                  emptyA_end98:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode98)
                    jmp Lcont98
                    MAKE_CLOSURE (rbx, rax, Lcode98)
                    jmp Lcont98
                  Lcode98:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +23
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA103				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2103:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2103			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2103
                  endLoop_2103:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2103:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2103
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2103
                  endLoopArgs_2103:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode103)
                    jmp Lcont103
                  emptyA103:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty103
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop103:
                    cmp rax, rcx
                    je emptyA_end103
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop103
                  bothEmpty103:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode103)
                    jmp Lcont103
                  emptyA_end103:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode103)
                    jmp Lcont103
                    MAKE_CLOSURE (rbx, rax, Lcode103)
                    jmp Lcont103
                  Lcode103:
                    push rbp
                    mov rbp, rsp
                    
mov rax, qword [rbp + 8*(4 + 0)]
                                 MALLOC rcx, 8
                                 mov [rcx], rax
                                 mov rax, rcx 
                                                         mov qword [rbp + 8*(4 + 0)], rax 
                                                         mov rax, SOB_VOID_ADDRESS

mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA114				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2114:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2114			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2114
                  endLoop_2114:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2114:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2114
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2114
                  endLoopArgs_2114:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode114)
                    jmp Lcont114
                  emptyA114:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty114
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop114:
                    cmp rax, rcx
                    je emptyA_end114
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop114
                  bothEmpty114:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode114)
                    jmp Lcont114
                  emptyA_end114:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode114)
                    jmp Lcont114
                    MAKE_CLOSURE (rbx, rax, Lcode114)
                    jmp Lcont114
                  Lcode114:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 2)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure135
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic135
                  notClosure135:
                    ;;;complete with segmentation fault
                  endApplic135: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse115 
                                            mov rax, qword [rbp + 8*(4 + 1)] 
                                            jmp Lexit115 
                                            Lelse115: 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 2)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure119
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic119
                  notClosure119:
                    ;;;complete with segmentation fault
                  endApplic119:
                                       push rax 
                                        
                                        
                                       mov rax, qword [rbp + 8*(4 + 2)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure125
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic125
                  notClosure125:
                    ;;;complete with segmentation fault
                  endApplic125:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*(4 + 0)]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure123
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic123
                  notClosure123:
                    ;;;complete with segmentation fault
                  endApplic123:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 3
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure117
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 7
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic117
                  notClosure117:
                    ;;;complete with segmentation fault
                  endApplic117: 
                                            Lexit115:
                    leave
                    ret
                  Lcont114: 
                                     push rax 
                                     mov rax, qword [rbp + 8*(4 + 0)] 
                                     pop qword [rax] 
                                     mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8*(4 + 0)] 
                                  mov rax, qword [rax]
                    leave
                    ret
                  Lcont103:
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure100
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic100
                  notClosure100:
                    ;;;complete with segmentation fault
                  endApplic100:
                    leave
                    ret
                  Lcont98:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure93
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic93
                  notClosure93:
                    ;;;complete with segmentation fault
                  endApplic93:
                                                 define_lable91: 
                                                 mov qword [fvar_tbl +240], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +192]
                                       push rax 
                                       mov rax, [fvar_tbl +184]
                                       push rax 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                    push 3
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA147				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2147:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2147			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2147
                  endLoop_2147:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2147:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2147
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2147
                  endLoopArgs_2147:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode147)
                    jmp Lcont147
                  emptyA147:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty147
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop147:
                    cmp rax, rcx
                    je emptyA_end147
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop147
                  bothEmpty147:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode147)
                    jmp Lcont147
                  emptyA_end147:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode147)
                    jmp Lcont147
                    MAKE_CLOSURE (rbx, rax, Lcode147)
                    jmp Lcont147
                  Lcode147:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +23
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA152				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2152:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2152			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2152
                  endLoop_2152:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2152:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2152
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2152
                  endLoopArgs_2152:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode152)
                    jmp Lcont152
                  emptyA152:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty152
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop152:
                    cmp rax, rcx
                    je emptyA_end152
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop152
                  bothEmpty152:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode152)
                    jmp Lcont152
                  emptyA_end152:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode152)
                    jmp Lcont152
                    MAKE_CLOSURE (rbx, rax, Lcode152)
                    jmp Lcont152
                  Lcode152:
                    push rbp
                    mov rbp, rsp
                    
mov rax, qword [rbp + 8*(4 + 0)]
                                 MALLOC rcx, 8
                                 mov [rcx], rax
                                 mov rax, rcx 
                                                         mov qword [rbp + 8*(4 + 0)], rax 
                                                         mov rax, SOB_VOID_ADDRESS

mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA163				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2163:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2163			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2163
                  endLoop_2163:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2163:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2163
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2163
                  endLoopArgs_2163:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode163)
                    jmp Lcont163
                  emptyA163:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty163
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop163:
                    cmp rax, rcx
                    je emptyA_end163
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop163
                  bothEmpty163:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode163)
                    jmp Lcont163
                  emptyA_end163:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode163)
                    jmp Lcont163
                    MAKE_CLOSURE (rbx, rax, Lcode163)
                    jmp Lcont163
                  Lcode163:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 2)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure184
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic184
                  notClosure184:
                    ;;;complete with segmentation fault
                  endApplic184: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse164 
                                            mov rax, qword [rbp + 8*(4 + 1)] 
                                            jmp Lexit164 
                                            Lelse164: 
                                             
                                        
                                        
                                       mov rax, qword [rbp + 8*(4 + 2)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure170
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic170
                  notClosure170:
                    ;;;complete with segmentation fault
                  endApplic170:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 3
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure168
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic168
                  notClosure168:
                    ;;;complete with segmentation fault
                  endApplic168:
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 2)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure178
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic178
                  notClosure178:
                    ;;;complete with segmentation fault
                  endApplic178:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*(4 + 0)]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure166
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic166
                  notClosure166:
                    ;;;complete with segmentation fault
                  endApplic166: 
                                            Lexit164:
                    leave
                    ret
                  Lcont163: 
                                     push rax 
                                     mov rax, qword [rbp + 8*(4 + 0)] 
                                     pop qword [rax] 
                                     mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8*(4 + 0)] 
                                  mov rax, qword [rax]
                    leave
                    ret
                  Lcont152:
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure149
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic149
                  notClosure149:
                    ;;;complete with segmentation fault
                  endApplic149:
                    leave
                    ret
                  Lcont147:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure142
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic142
                  notClosure142:
                    ;;;complete with segmentation fault
                  endApplic142:
                                                 define_lable140: 
                                                 mov qword [fvar_tbl +248], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +184]
                                       push rax 
                                       mov rax, [fvar_tbl +192]
                                       push rax 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                    push 3
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA196				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2196:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2196			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2196
                  endLoop_2196:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2196:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2196
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2196
                  endLoopArgs_2196:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode196)
                    jmp Lcont196
                  emptyA196:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty196
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop196:
                    cmp rax, rcx
                    je emptyA_end196
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop196
                  bothEmpty196:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode196)
                    jmp Lcont196
                  emptyA_end196:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode196)
                    jmp Lcont196
                    MAKE_CLOSURE (rbx, rax, Lcode196)
                    jmp Lcont196
                  Lcode196:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +23
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA201				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2201:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2201			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2201
                  endLoop_2201:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2201:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2201
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2201
                  endLoopArgs_2201:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode201)
                    jmp Lcont201
                  emptyA201:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty201
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop201:
                    cmp rax, rcx
                    je emptyA_end201
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop201
                  bothEmpty201:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode201)
                    jmp Lcont201
                  emptyA_end201:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode201)
                    jmp Lcont201
                    MAKE_CLOSURE (rbx, rax, Lcode201)
                    jmp Lcont201
                  Lcode201:
                    push rbp
                    mov rbp, rsp
                    
mov rax, qword [rbp + 8*(4 + 0)]
                                 MALLOC rcx, 8
                                 mov [rcx], rax
                                 mov rax, rcx 
                                                         mov qword [rbp + 8*(4 + 0)], rax 
                                                         mov rax, SOB_VOID_ADDRESS

 mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA212				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2212:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2212			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2212
                  endLoop_2212:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2212:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2212
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2212
                  endLoopArgs_2212:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode212)
                    jmp Lcont212
                  emptyA212:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty212
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop212:
                    cmp rax, rcx
                    je emptyA_end212
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop212
                  bothEmpty212:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode212)
                    jmp Lcont212
                  emptyA_end212:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode212)
                    jmp Lcont212
                  Lcode212:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 1                         ;;;cmp rbx numOfArgs
                    jge shrink212                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 24                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing212
                  shrink212:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 0                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink212:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink212
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink212
                  endLoopShrink212:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 24                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 1            ;;;newN= numArgs
                  doNothing212:
                    push rbp
                    mov rbp, rsp
                     
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure237
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic237
                  notClosure237:
                    ;;;complete with segmentation fault
                  endApplic237:
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure235
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic235
                  notClosure235:
                    ;;;complete with segmentation fault
                  endApplic235: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse213 
                                             
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure231
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic231
                  notClosure231:
                    ;;;complete with segmentation fault
                  endApplic231: 
                                            jmp Lexit213 
                                            Lelse213: 
                                             
                                        
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure219
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic219
                  notClosure219:
                    ;;;complete with segmentation fault
                  endApplic219:
                                       push rax 
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                                       push rax 
                    push 2
                    mov rax, [fvar_tbl +224]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure217
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic217
                  notClosure217:
                    ;;;complete with segmentation fault
                  endApplic217:
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure226
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic226
                  notClosure226:
                    ;;;complete with segmentation fault
                  endApplic226:
                                       push rax 
                    push 2
                    mov rax, [fvar_tbl +200]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure215
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic215
                  notClosure215:
                    ;;;complete with segmentation fault
                  endApplic215: 
                                            Lexit213:
                    leave
                    ret
                  Lcont212: 
                                     push rax 
                                     mov rax, qword [rbp + 8*(4 + 0)] 
                                     pop qword [rax] 
                                     mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8*(4 + 0)] 
                                  mov rax, qword [rax]
                    leave
                    ret
                  Lcont201:
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure198
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic198
                  notClosure198:
                    ;;;complete with segmentation fault
                  endApplic198:
                    leave
                    ret
                  Lcont196:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure191
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic191
                  notClosure191:
                    ;;;complete with segmentation fault
                  endApplic191:
                                                 define_lable189: 
                                                 mov qword [fvar_tbl +256], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +200]
                                       push rax 
                                       mov rax, [fvar_tbl +248]
                                       push rax 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                    push 3
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA250				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2250:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2250			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2250
                  endLoop_2250:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2250:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2250
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2250
                  endLoopArgs_2250:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode250)
                    jmp Lcont250
                  emptyA250:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty250
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop250:
                    cmp rax, rcx
                    je emptyA_end250
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop250
                  bothEmpty250:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode250)
                    jmp Lcont250
                  emptyA_end250:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode250)
                    jmp Lcont250
                    MAKE_CLOSURE (rbx, rax, Lcode250)
                    jmp Lcont250
                  Lcode250:
                    push rbp
                    mov rbp, rsp
                     mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA252				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2252:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2252			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2252
                  endLoop_2252:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2252:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2252
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2252
                  endLoopArgs_2252:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode252)
                    jmp Lcont252
                  emptyA252:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty252
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop252:
                    cmp rax, rcx
                    je emptyA_end252
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop252
                  bothEmpty252:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode252)
                    jmp Lcont252
                  emptyA_end252:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode252)
                    jmp Lcont252
                  Lcode252:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 1                         ;;;cmp rbx numOfArgs
                    jge shrink252                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 24                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing252
                  shrink252:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 0                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink252:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink252
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink252
                  endLoopShrink252:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 24                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 1            ;;;newN= numArgs
                  doNothing252:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, const_tbl +1
                                       push rax 
                                       mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA258				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2258:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2258			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2258
                  endLoop_2258:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2258:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2258
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2258
                  endLoopArgs_2258:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode258)
                    jmp Lcont258
                  emptyA258:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty258
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop258:
                    cmp rax, rcx
                    je emptyA_end258
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop258
                  bothEmpty258:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode258)
                    jmp Lcont258
                  emptyA_end258:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode258)
                    jmp Lcont258
                    MAKE_CLOSURE (rbx, rax, Lcode258)
                    jmp Lcont258
                  Lcode258:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure268
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic268
                  notClosure268:
                    ;;;complete with segmentation fault
                  endApplic268: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse259 
                                            mov rax, qword [rbp + 8*(4 + 0)] 
                                            jmp Lexit259 
                                            Lelse259: 
                                             
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                                       push rax 
                    push 3
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure261
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 7
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic261
                  notClosure261:
                    ;;;complete with segmentation fault
                  endApplic261: 
                                            Lexit259:
                    leave
                    ret
                  Lcont258:
                                       push rax 
                    push 3
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*1]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure254
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 7
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic254
                  notClosure254:
                    ;;;complete with segmentation fault
                  endApplic254:
                    leave
                    ret
                  Lcont252:
                    leave
                    ret
                  Lcont250:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure245
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic245
                  notClosure245:
                    ;;;complete with segmentation fault
                  endApplic245:
                                                 define_lable243: 
                                                 mov qword [fvar_tbl +264], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA274				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2274:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2274			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2274
                  endLoop_2274:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2274:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2274
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2274
                  endLoopArgs_2274:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode274)
                    jmp Lcont274
                  emptyA274:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty274
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop274:
                    cmp rax, rcx
                    je emptyA_end274
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop274
                  bothEmpty274:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode274)
                    jmp Lcont274
                  emptyA_end274:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode274)
                    jmp Lcont274
                  Lcode274:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 1                         ;;;cmp rbx numOfArgs
                    jge shrink274                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 24                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing274
                  shrink274:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 0                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink274:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink274
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink274
                  endLoopShrink274:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 24                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 1            ;;;newN= numArgs
                  doNothing274:
                    push rbp
                    mov rbp, rsp
                    mov rax, qword [rbp + 8*(4 + 0)]
                    leave
                    ret
                  Lcont274:
                                                 define_lable272: 
                                                 mov qword [fvar_tbl +272], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +192]
                                       push rax 
                                       mov rax, [fvar_tbl +24]
                                       push rax 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                    push 3
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA283				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2283:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2283			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2283
                  endLoop_2283:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2283:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2283
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2283
                  endLoopArgs_2283:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode283)
                    jmp Lcont283
                  emptyA283:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty283
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop283:
                    cmp rax, rcx
                    je emptyA_end283
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop283
                  bothEmpty283:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode283)
                    jmp Lcont283
                  emptyA_end283:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode283)
                    jmp Lcont283
                    MAKE_CLOSURE (rbx, rax, Lcode283)
                    jmp Lcont283
                  Lcode283:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +23
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA288				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2288:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2288			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2288
                  endLoop_2288:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2288:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2288
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2288
                  endLoopArgs_2288:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode288)
                    jmp Lcont288
                  emptyA288:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty288
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop288:
                    cmp rax, rcx
                    je emptyA_end288
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop288
                  bothEmpty288:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode288)
                    jmp Lcont288
                  emptyA_end288:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode288)
                    jmp Lcont288
                    MAKE_CLOSURE (rbx, rax, Lcode288)
                    jmp Lcont288
                  Lcode288:
                    push rbp
                    mov rbp, rsp
                    
mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA293				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2293:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2293			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2293
                  endLoop_2293:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2293:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2293
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2293
                  endLoopArgs_2293:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode293)
                    jmp Lcont293
                  emptyA293:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty293
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop293:
                    cmp rax, rcx
                    je emptyA_end293
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop293
                  bothEmpty293:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode293)
                    jmp Lcont293
                  emptyA_end293:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode293)
                    jmp Lcont293
                    MAKE_CLOSURE (rbx, rax, Lcode293)
                    jmp Lcont293
                  Lcode293:
                    push rbp
                    mov rbp, rsp
                    
 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure310
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic310
                  notClosure310:
                    ;;;complete with segmentation fault
                  endApplic310: 
                                                cmp rax, SOB_FALSE_ADDRESS 
                                                jne Lexit295 
                   
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure306
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic306
                  notClosure306:
                    ;;;complete with segmentation fault
                  endApplic306: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse296 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure301
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic301
                  notClosure301:
                    ;;;complete with segmentation fault
                  endApplic301:
                                       push rax 
                    push 1
                    mov rax, [fvar_tbl +280]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure299
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic299
                  notClosure299:
                    ;;;complete with segmentation fault
                  endApplic299: 
                                            jmp Lexit296 
                                            Lelse296: 
                                            mov rax, const_tbl +4 
                                            Lexit296: 
                  Lexit295:
                    leave
                    ret
                  Lcont293: 
                                                         mov qword [rbp + 8*(4 + 0)], rax 
                                                         mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8*(4 + 0)]
                    leave
                    ret
                  Lcont288:
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure285
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic285
                  notClosure285:
                    ;;;complete with segmentation fault
                  endApplic285:
                    leave
                    ret
                  Lcont283:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure278
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic278
                  notClosure278:
                    ;;;complete with segmentation fault
                  endApplic278:
                                                 define_lable276: 
                                                 mov qword [fvar_tbl +280], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +136]
                                       push rax 
                                       mov rax, [fvar_tbl +240]
                                       push rax 
                    push 2
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA320				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2320:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2320			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2320
                  endLoop_2320:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2320:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2320
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2320
                  endLoopArgs_2320:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode320)
                    jmp Lcont320
                  emptyA320:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty320
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop320:
                    cmp rax, rcx
                    je emptyA_end320
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop320
                  bothEmpty320:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode320)
                    jmp Lcont320
                  emptyA_end320:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode320)
                    jmp Lcont320
                    MAKE_CLOSURE (rbx, rax, Lcode320)
                    jmp Lcont320
                  Lcode320:
                    push rbp
                    mov rbp, rsp
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA322				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2322:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2322			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2322
                  endLoop_2322:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2322:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2322
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2322
                  endLoopArgs_2322:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode322)
                    jmp Lcont322
                  emptyA322:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty322
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop322:
                    cmp rax, rcx
                    je emptyA_end322
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop322
                  bothEmpty322:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode322)
                    jmp Lcont322
                  emptyA_end322:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode322)
                    jmp Lcont322
                    MAKE_CLOSURE (rbx, rax, Lcode322)
                    jmp Lcont322
                  Lcode322:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, const_tbl +41
                                       push rax 
                                       mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA328				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2328:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2328			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2328
                  endLoop_2328:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2328:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2328
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2328
                  endLoopArgs_2328:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode328)
                    jmp Lcont328
                  emptyA328:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty328
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop328:
                    cmp rax, rcx
                    je emptyA_end328
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop328
                  bothEmpty328:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode328)
                    jmp Lcont328
                  emptyA_end328:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode328)
                    jmp Lcont328
                    MAKE_CLOSURE (rbx, rax, Lcode328)
                    jmp Lcont328
                  Lcode328:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +32
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure330
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic330
                  notClosure330:
                    ;;;complete with segmentation fault
                  endApplic330:
                    leave
                    ret
                  Lcont328:
                                       push rax 
                    push 3
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure324
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 7
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic324
                  notClosure324:
                    ;;;complete with segmentation fault
                  endApplic324:
                    leave
                    ret
                  Lcont322:
                    leave
                    ret
                  Lcont320:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure316
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic316
                  notClosure316:
                    ;;;complete with segmentation fault
                  endApplic316:
                                                 define_lable314: 
                                                 mov qword [fvar_tbl +288], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +96]
                                       push rax 
                                       mov rax, [fvar_tbl +184]
                                       push rax 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                    push 3
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA342				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2342:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2342			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2342
                  endLoop_2342:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2342:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2342
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2342
                  endLoopArgs_2342:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode342)
                    jmp Lcont342
                  emptyA342:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty342
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop342:
                    cmp rax, rcx
                    je emptyA_end342
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop342
                  bothEmpty342:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode342)
                    jmp Lcont342
                  emptyA_end342:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode342)
                    jmp Lcont342
                    MAKE_CLOSURE (rbx, rax, Lcode342)
                    jmp Lcont342
                  Lcode342:
                    push rbp
                    mov rbp, rsp
                     mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA344				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2344:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2344			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2344
                  endLoop_2344:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2344:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2344
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2344
                  endLoopArgs_2344:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode344)
                    jmp Lcont344
                  emptyA344:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty344
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop344:
                    cmp rax, rcx
                    je emptyA_end344
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop344
                  bothEmpty344:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode344)
                    jmp Lcont344
                  emptyA_end344:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode344)
                    jmp Lcont344
                  Lcode344:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 2                         ;;;cmp rbx numOfArgs
                    jge shrink344                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 32                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing344
                  shrink344:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 1                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink344:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink344
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink344
                  endLoopShrink344:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 32                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 2            ;;;newN= numArgs
                  doNothing344:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure360
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic360
                  notClosure360:
                    ;;;complete with segmentation fault
                  endApplic360: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse345 
                                             
                                       mov rax, const_tbl +50
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*2]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure355
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic355
                  notClosure355:
                    ;;;complete with segmentation fault
                  endApplic355: 
                                            jmp Lexit345 
                                            Lelse345: 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure349
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic349
                  notClosure349:
                    ;;;complete with segmentation fault
                  endApplic349:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*2]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure347
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic347
                  notClosure347:
                    ;;;complete with segmentation fault
                  endApplic347: 
                                            Lexit345:
                    leave
                    ret
                  Lcont344:
                    leave
                    ret
                  Lcont342:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure337
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic337
                  notClosure337:
                    ;;;complete with segmentation fault
                  endApplic337:
                                                 define_lable335: 
                                                 mov qword [fvar_tbl +96], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA365				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2365:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2365			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2365
                  endLoop_2365:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2365:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2365
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2365
                  endLoopArgs_2365:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode365)
                    jmp Lcont365
                  emptyA365:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty365
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop365:
                    cmp rax, rcx
                    je emptyA_end365
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop365
                  bothEmpty365:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode365)
                    jmp Lcont365
                  emptyA_end365:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode365)
                    jmp Lcont365
                    MAKE_CLOSURE (rbx, rax, Lcode365)
                    jmp Lcont365
                  Lcode365:
                    push rbp
                    mov rbp, rsp
                    mov rax, qword [rbp + 8*(4 + 0)] 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse366 
                                            mov rax, const_tbl +4 
                                            jmp Lexit366 
                                            Lelse366: 
                                            mov rax, const_tbl +2 
                                            Lexit366:
                    leave
                    ret
                  Lcont365:
                                                 define_lable363: 
                                                 mov qword [fvar_tbl +296], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +16]
                                       push rax 
                                       mov rax, [fvar_tbl +8]
                                       push rax 
                    push 2
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA376				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2376:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2376			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2376
                  endLoop_2376:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2376:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2376
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2376
                  endLoopArgs_2376:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode376)
                    jmp Lcont376
                  emptyA376:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty376
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop376:
                    cmp rax, rcx
                    je emptyA_end376
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop376
                  bothEmpty376:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode376)
                    jmp Lcont376
                  emptyA_end376:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode376)
                    jmp Lcont376
                    MAKE_CLOSURE (rbx, rax, Lcode376)
                    jmp Lcont376
                  Lcode376:
                    push rbp
                    mov rbp, rsp
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA378				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2378:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2378			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2378
                  endLoop_2378:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2378:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2378
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2378
                  endLoopArgs_2378:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode378)
                    jmp Lcont378
                  emptyA378:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty378
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop378:
                    cmp rax, rcx
                    je emptyA_end378
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop378
                  bothEmpty378:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode378)
                    jmp Lcont378
                  emptyA_end378:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode378)
                    jmp Lcont378
                    MAKE_CLOSURE (rbx, rax, Lcode378)
                    jmp Lcont378
                  Lcode378:
                    push rbp
                    mov rbp, rsp
                    
 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure386
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic386
                  notClosure386:
                    ;;;complete with segmentation fault
                  endApplic386: 
                                                cmp rax, SOB_FALSE_ADDRESS 
                                                jne Lexit380 
                   
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*1]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure382
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic382
                  notClosure382:
                    ;;;complete with segmentation fault
                  endApplic382: 
                  Lexit380:
                    leave
                    ret
                  Lcont378:
                    leave
                    ret
                  Lcont376:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure372
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic372
                  notClosure372:
                    ;;;complete with segmentation fault
                  endApplic372:
                                                 define_lable370: 
                                                 mov qword [fvar_tbl +304], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +136]
                                       push rax 
                                       mov rax, [fvar_tbl +240]
                                       push rax 
                    push 2
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA395				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2395:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2395			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2395
                  endLoop_2395:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2395:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2395
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2395
                  endLoopArgs_2395:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode395)
                    jmp Lcont395
                  emptyA395:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty395
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop395:
                    cmp rax, rcx
                    je emptyA_end395
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop395
                  bothEmpty395:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode395)
                    jmp Lcont395
                  emptyA_end395:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode395)
                    jmp Lcont395
                    MAKE_CLOSURE (rbx, rax, Lcode395)
                    jmp Lcont395
                  Lcode395:
                    push rbp
                    mov rbp, rsp
                     mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA397				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2397:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2397			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2397
                  endLoop_2397:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2397:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2397
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2397
                  endLoopArgs_2397:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode397)
                    jmp Lcont397
                  emptyA397:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty397
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop397:
                    cmp rax, rcx
                    je emptyA_end397
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop397
                  bothEmpty397:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode397)
                    jmp Lcont397
                  emptyA_end397:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode397)
                    jmp Lcont397
                  Lcode397:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 1                         ;;;cmp rbx numOfArgs
                    jge shrink397                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 24                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing397
                  shrink397:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 0                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink397:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink397
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink397
                  endLoopShrink397:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 24                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 1            ;;;newN= numArgs
                  doNothing397:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, const_tbl +41
                                       push rax 
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*1]
                                       push rax 
                    push 3
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure399
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 7
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic399
                  notClosure399:
                    ;;;complete with segmentation fault
                  endApplic399:
                    leave
                    ret
                  Lcont397:
                    leave
                    ret
                  Lcont395:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure391
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic391
                  notClosure391:
                    ;;;complete with segmentation fault
                  endApplic391:
                                                 define_lable389: 
                                                 mov qword [fvar_tbl +136], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +144]
                                       push rax 
                                       mov rax, [fvar_tbl +240]
                                       push rax 
                    push 2
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA410				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2410:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2410			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2410
                  endLoop_2410:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2410:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2410
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2410
                  endLoopArgs_2410:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode410)
                    jmp Lcont410
                  emptyA410:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty410
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop410:
                    cmp rax, rcx
                    je emptyA_end410
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop410
                  bothEmpty410:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode410)
                    jmp Lcont410
                  emptyA_end410:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode410)
                    jmp Lcont410
                    MAKE_CLOSURE (rbx, rax, Lcode410)
                    jmp Lcont410
                  Lcode410:
                    push rbp
                    mov rbp, rsp
                     mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA412				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2412:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2412			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2412
                  endLoop_2412:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2412:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2412
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2412
                  endLoopArgs_2412:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode412)
                    jmp Lcont412
                  emptyA412:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty412
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop412:
                    cmp rax, rcx
                    je emptyA_end412
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop412
                  bothEmpty412:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode412)
                    jmp Lcont412
                  emptyA_end412:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode412)
                    jmp Lcont412
                  Lcode412:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 1                         ;;;cmp rbx numOfArgs
                    jge shrink412                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 24                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing412
                  shrink412:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 0                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink412:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink412
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink412
                  endLoopShrink412:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 24                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 1            ;;;newN= numArgs
                  doNothing412:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, const_tbl +32
                                       push rax 
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*1]
                                       push rax 
                    push 3
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure414
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 7
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic414
                  notClosure414:
                    ;;;complete with segmentation fault
                  endApplic414:
                    leave
                    ret
                  Lcont412:
                    leave
                    ret
                  Lcont410:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure406
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic406
                  notClosure406:
                    ;;;complete with segmentation fault
                  endApplic406:
                                                 define_lable404: 
                                                 mov qword [fvar_tbl +144], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                                       mov rax, [fvar_tbl +136]
                                       push rax 
                                       mov rax, [fvar_tbl +152]
                                       push rax 
                                       mov rax, [fvar_tbl +224]
                                       push rax 
                    push 4
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA427				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2427:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2427			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2427
                  endLoop_2427:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2427:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2427
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2427
                  endLoopArgs_2427:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode427)
                    jmp Lcont427
                  emptyA427:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty427
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop427:
                    cmp rax, rcx
                    je emptyA_end427
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop427
                  bothEmpty427:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode427)
                    jmp Lcont427
                  emptyA_end427:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode427)
                    jmp Lcont427
                    MAKE_CLOSURE (rbx, rax, Lcode427)
                    jmp Lcont427
                  Lcode427:
                    push rbp
                    mov rbp, rsp
                     mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA429				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2429:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2429			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2429
                  endLoop_2429:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2429:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2429
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2429
                  endLoopArgs_2429:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode429)
                    jmp Lcont429
                  emptyA429:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty429
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop429:
                    cmp rax, rcx
                    je emptyA_end429
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop429
                  bothEmpty429:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode429)
                    jmp Lcont429
                  emptyA_end429:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode429)
                    jmp Lcont429
                  Lcode429:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 2                         ;;;cmp rbx numOfArgs
                    jge shrink429                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 32                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing429
                  shrink429:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 1                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink429:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink429
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink429
                  endLoopShrink429:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 32                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 2            ;;;newN= numArgs
                  doNothing429:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*3]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure446
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic446
                  notClosure446:
                    ;;;complete with segmentation fault
                  endApplic446: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse430 
                                             
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, const_tbl +41
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*1]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure441
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic441
                  notClosure441:
                    ;;;complete with segmentation fault
                  endApplic441: 
                                            jmp Lexit430 
                                            Lelse430: 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*2]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure434
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic434
                  notClosure434:
                    ;;;complete with segmentation fault
                  endApplic434:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*1]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure432
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic432
                  notClosure432:
                    ;;;complete with segmentation fault
                  endApplic432: 
                                            Lexit430:
                    leave
                    ret
                  Lcont429:
                    leave
                    ret
                  Lcont427:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure421
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic421
                  notClosure421:
                    ;;;complete with segmentation fault
                  endApplic421:
                                                 define_lable419: 
                                                 mov qword [fvar_tbl +152], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                                       mov rax, [fvar_tbl +144]
                                       push rax 
                                       mov rax, [fvar_tbl +160]
                                       push rax 
                                       mov rax, [fvar_tbl +224]
                                       push rax 
                    push 4
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA457				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2457:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2457			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2457
                  endLoop_2457:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2457:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2457
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2457
                  endLoopArgs_2457:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode457)
                    jmp Lcont457
                  emptyA457:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty457
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop457:
                    cmp rax, rcx
                    je emptyA_end457
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop457
                  bothEmpty457:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode457)
                    jmp Lcont457
                  emptyA_end457:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode457)
                    jmp Lcont457
                    MAKE_CLOSURE (rbx, rax, Lcode457)
                    jmp Lcont457
                  Lcode457:
                    push rbp
                    mov rbp, rsp
                     mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA459				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2459:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2459			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2459
                  endLoop_2459:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2459:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2459
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2459
                  endLoopArgs_2459:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode459)
                    jmp Lcont459
                  emptyA459:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty459
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop459:
                    cmp rax, rcx
                    je emptyA_end459
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop459
                  bothEmpty459:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode459)
                    jmp Lcont459
                  emptyA_end459:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode459)
                    jmp Lcont459
                  Lcode459:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 2                         ;;;cmp rbx numOfArgs
                    jge shrink459                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 32                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing459
                  shrink459:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 1                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink459:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink459
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink459
                  endLoopShrink459:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 32                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 2            ;;;newN= numArgs
                  doNothing459:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*3]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure476
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic476
                  notClosure476:
                    ;;;complete with segmentation fault
                  endApplic476: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse460 
                                             
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, const_tbl +32
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*1]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure471
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic471
                  notClosure471:
                    ;;;complete with segmentation fault
                  endApplic471: 
                                            jmp Lexit460 
                                            Lelse460: 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*2]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure464
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic464
                  notClosure464:
                    ;;;complete with segmentation fault
                  endApplic464:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*1]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure462
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic462
                  notClosure462:
                    ;;;complete with segmentation fault
                  endApplic462: 
                                            Lexit460:
                    leave
                    ret
                  Lcont459:
                    leave
                    ret
                  Lcont457:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure451
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic451
                  notClosure451:
                    ;;;complete with segmentation fault
                  endApplic451:
                                                 define_lable449: 
                                                 mov qword [fvar_tbl +160], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +224]
                                       push rax 
                                       mov rax, [fvar_tbl +192]
                                       push rax 
                                       mov rax, [fvar_tbl +184]
                                       push rax 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                                       mov rax, [fvar_tbl +176]
                                       push rax 
                    push 5
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA488				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2488:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2488			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2488
                  endLoop_2488:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2488:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2488
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2488
                  endLoopArgs_2488:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode488)
                    jmp Lcont488
                  emptyA488:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty488
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop488:
                    cmp rax, rcx
                    je emptyA_end488
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop488
                  bothEmpty488:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode488)
                    jmp Lcont488
                  emptyA_end488:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode488)
                    jmp Lcont488
                    MAKE_CLOSURE (rbx, rax, Lcode488)
                    jmp Lcont488
                  Lcode488:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +23
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA493				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2493:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2493			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2493
                  endLoop_2493:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2493:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2493
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2493
                  endLoopArgs_2493:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode493)
                    jmp Lcont493
                  emptyA493:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty493
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop493:
                    cmp rax, rcx
                    je emptyA_end493
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop493
                  bothEmpty493:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode493)
                    jmp Lcont493
                  emptyA_end493:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode493)
                    jmp Lcont493
                    MAKE_CLOSURE (rbx, rax, Lcode493)
                    jmp Lcont493
                  Lcode493:
                    push rbp
                    mov rbp, rsp
                    
mov rax, qword [rbp + 8*(4 + 0)]
                                 MALLOC rcx, 8
                                 mov [rcx], rax
                                 mov rax, rcx 
                                                         mov qword [rbp + 8*(4 + 0)], rax 
                                                         mov rax, SOB_VOID_ADDRESS

 mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA504				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2504:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2504			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2504
                  endLoop_2504:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2504:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2504
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2504
                  endLoopArgs_2504:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode504)
                    jmp Lcont504
                  emptyA504:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty504
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop504:
                    cmp rax, rcx
                    je emptyA_end504
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop504
                  bothEmpty504:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode504)
                    jmp Lcont504
                  emptyA_end504:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode504)
                    jmp Lcont504
                  Lcode504:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 2                         ;;;cmp rbx numOfArgs
                    jge shrink504                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 32                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing504
                  shrink504:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 1                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink504:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink504
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink504
                  endLoopShrink504:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 32                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 2            ;;;newN= numArgs
                  doNothing504:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure528
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic528
                  notClosure528:
                    ;;;complete with segmentation fault
                  endApplic528: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse505 
                                            mov rax, const_tbl +2 
                                            jmp Lexit505 
                                            Lelse505: 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure521
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic521
                  notClosure521:
                    ;;;complete with segmentation fault
                  endApplic521:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure519
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic519
                  notClosure519:
                    ;;;complete with segmentation fault
                  endApplic519: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse506 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*3]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure511
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic511
                  notClosure511:
                    ;;;complete with segmentation fault
                  endApplic511:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                                       push rax 
                    push 3
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*4]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure509
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 7
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic509
                  notClosure509:
                    ;;;complete with segmentation fault
                  endApplic509: 
                                            jmp Lexit506 
                                            Lelse506: 
                                            mov rax, const_tbl +4 
                                            Lexit506: 
                                            Lexit505:
                    leave
                    ret
                  Lcont504: 
                                     push rax 
                                     mov rax, qword [rbp + 8*(4 + 0)] 
                                     pop qword [rax] 
                                     mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8*(4 + 0)] 
                                  mov rax, qword [rax]
                    leave
                    ret
                  Lcont493:
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure490
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic490
                  notClosure490:
                    ;;;complete with segmentation fault
                  endApplic490:
                    leave
                    ret
                  Lcont488:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure481
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic481
                  notClosure481:
                    ;;;complete with segmentation fault
                  endApplic481:
                                                 define_lable479: 
                                                 mov qword [fvar_tbl +176], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +192]
                                       push rax 
                                       mov rax, [fvar_tbl +184]
                                       push rax 
                                       mov rax, [fvar_tbl +168]
                                       push rax 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                    push 4
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA541				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2541:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2541			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2541
                  endLoop_2541:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2541:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2541
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2541
                  endLoopArgs_2541:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode541)
                    jmp Lcont541
                  emptyA541:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty541
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop541:
                    cmp rax, rcx
                    je emptyA_end541
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop541
                  bothEmpty541:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode541)
                    jmp Lcont541
                  emptyA_end541:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode541)
                    jmp Lcont541
                    MAKE_CLOSURE (rbx, rax, Lcode541)
                    jmp Lcont541
                  Lcode541:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +23
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA546				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2546:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2546			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2546
                  endLoop_2546:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2546:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2546
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2546
                  endLoopArgs_2546:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode546)
                    jmp Lcont546
                  emptyA546:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty546
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop546:
                    cmp rax, rcx
                    je emptyA_end546
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop546
                  bothEmpty546:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode546)
                    jmp Lcont546
                  emptyA_end546:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode546)
                    jmp Lcont546
                    MAKE_CLOSURE (rbx, rax, Lcode546)
                    jmp Lcont546
                  Lcode546:
                    push rbp
                    mov rbp, rsp
                    
mov rax, qword [rbp + 8*(4 + 0)]
                                 MALLOC rcx, 8
                                 mov [rcx], rax
                                 mov rax, rcx 
                                                         mov qword [rbp + 8*(4 + 0)], rax 
                                                         mov rax, SOB_VOID_ADDRESS

mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA557				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2557:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2557			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2557
                  endLoop_2557:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2557:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2557
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2557
                  endLoopArgs_2557:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode557)
                    jmp Lcont557
                  emptyA557:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty557
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop557:
                    cmp rax, rcx
                    je emptyA_end557
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop557
                  bothEmpty557:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode557)
                    jmp Lcont557
                  emptyA_end557:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode557)
                    jmp Lcont557
                    MAKE_CLOSURE (rbx, rax, Lcode557)
                    jmp Lcont557
                  Lcode557:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure583
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic583
                  notClosure583:
                    ;;;complete with segmentation fault
                  endApplic583: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse558 
                                            mov rax, const_tbl +2 
                                            jmp Lexit558 
                                            Lelse558: 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure576
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic576
                  notClosure576:
                    ;;;complete with segmentation fault
                  endApplic576:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure574
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic574
                  notClosure574:
                    ;;;complete with segmentation fault
                  endApplic574: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse559 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*3]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure564
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic564
                  notClosure564:
                    ;;;complete with segmentation fault
                  endApplic564:
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure568
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic568
                  notClosure568:
                    ;;;complete with segmentation fault
                  endApplic568:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure562
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic562
                  notClosure562:
                    ;;;complete with segmentation fault
                  endApplic562: 
                                            jmp Lexit559 
                                            Lelse559: 
                                            mov rax, const_tbl +4 
                                            Lexit559: 
                                            Lexit558:
                    leave
                    ret
                  Lcont557: 
                                     push rax 
                                     mov rax, qword [rbp + 8*(4 + 0)] 
                                     pop qword [rax] 
                                     mov rax, SOB_VOID_ADDRESS
 mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA587				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2587:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2587			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2587
                  endLoop_2587:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2587:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2587
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2587
                  endLoopArgs_2587:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode587)
                    jmp Lcont587
                  emptyA587:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty587
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop587:
                    cmp rax, rcx
                    je emptyA_end587
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop587
                  bothEmpty587:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode587)
                    jmp Lcont587
                  emptyA_end587:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode587)
                    jmp Lcont587
                  Lcode587:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 2                         ;;;cmp rbx numOfArgs
                    jge shrink587                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 32                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing587
                  shrink587:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 1                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink587:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink587
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink587
                  endLoopShrink587:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 32                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 2            ;;;newN= numArgs
                  doNothing587:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure589
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic589
                  notClosure589:
                    ;;;complete with segmentation fault
                  endApplic589:
                    leave
                    ret
                  Lcont587:
                    leave
                    ret
                  Lcont546:
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure543
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic543
                  notClosure543:
                    ;;;complete with segmentation fault
                  endApplic543:
                    leave
                    ret
                  Lcont541:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure535
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic535
                  notClosure535:
                    ;;;complete with segmentation fault
                  endApplic535:
                                                 define_lable533: 
                                                 mov qword [fvar_tbl +168], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +192]
                                       push rax 
                                       mov rax, [fvar_tbl +184]
                                       push rax 
                                       mov rax, [fvar_tbl +296]
                                       push rax 
                                       mov rax, [fvar_tbl +176]
                                       push rax 
                                       mov rax, [fvar_tbl +168]
                                       push rax 
                                       mov rax, [fvar_tbl +32]
                                       push rax 
                    push 6
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA604				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2604:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2604			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2604
                  endLoop_2604:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2604:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2604
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2604
                  endLoopArgs_2604:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode604)
                    jmp Lcont604
                  emptyA604:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty604
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop604:
                    cmp rax, rcx
                    je emptyA_end604
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop604
                  bothEmpty604:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode604)
                    jmp Lcont604
                  emptyA_end604:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode604)
                    jmp Lcont604
                    MAKE_CLOSURE (rbx, rax, Lcode604)
                    jmp Lcont604
                  Lcode604:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +23
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA609				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2609:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2609			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2609
                  endLoop_2609:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2609:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2609
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2609
                  endLoopArgs_2609:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode609)
                    jmp Lcont609
                  emptyA609:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty609
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop609:
                    cmp rax, rcx
                    je emptyA_end609
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop609
                  bothEmpty609:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode609)
                    jmp Lcont609
                  emptyA_end609:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode609)
                    jmp Lcont609
                    MAKE_CLOSURE (rbx, rax, Lcode609)
                    jmp Lcont609
                  Lcode609:
                    push rbp
                    mov rbp, rsp
                    
mov rax, qword [rbp + 8*(4 + 0)]
                                 MALLOC rcx, 8
                                 mov [rcx], rax
                                 mov rax, rcx 
                                                         mov qword [rbp + 8*(4 + 0)], rax 
                                                         mov rax, SOB_VOID_ADDRESS

mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA620				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2620:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2620			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2620
                  endLoop_2620:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2620:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2620
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2620
                  endLoopArgs_2620:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode620)
                    jmp Lcont620
                  emptyA620:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty620
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop620:
                    cmp rax, rcx
                    je emptyA_end620
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop620
                  bothEmpty620:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode620)
                    jmp Lcont620
                  emptyA_end620:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode620)
                    jmp Lcont620
                    MAKE_CLOSURE (rbx, rax, Lcode620)
                    jmp Lcont620
                  Lcode620:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure659
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic659
                  notClosure659:
                    ;;;complete with segmentation fault
                  endApplic659: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse621 
                                            mov rax, const_tbl +2 
                                            jmp Lexit621 
                                            Lelse621: 
                                             
                                       
 
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*4]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure651
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic651
                  notClosure651:
                    ;;;complete with segmentation fault
                  endApplic651:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure649
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic649
                  notClosure649:
                    ;;;complete with segmentation fault
                  endApplic649: 
                                                cmp rax, SOB_FALSE_ADDRESS 
                                                jne Lexit639 
                   
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*4]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure643
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic643
                  notClosure643:
                    ;;;complete with segmentation fault
                  endApplic643:
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure641
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic641
                  notClosure641:
                    ;;;complete with segmentation fault
                  endApplic641: 
                  Lexit639:
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*3]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure637
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic637
                  notClosure637:
                    ;;;complete with segmentation fault
                  endApplic637: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse622 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*5]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure627
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic627
                  notClosure627:
                    ;;;complete with segmentation fault
                  endApplic627:
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*4]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure631
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic631
                  notClosure631:
                    ;;;complete with segmentation fault
                  endApplic631:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure625
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic625
                  notClosure625:
                    ;;;complete with segmentation fault
                  endApplic625: 
                                            jmp Lexit622 
                                            Lelse622: 
                                            mov rax, const_tbl +4 
                                            Lexit622: 
                                            Lexit621:
                    leave
                    ret
                  Lcont620: 
                                     push rax 
                                     mov rax, qword [rbp + 8*(4 + 0)] 
                                     pop qword [rax] 
                                     mov rax, SOB_VOID_ADDRESS
 mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA663				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2663:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2663			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2663
                  endLoop_2663:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2663:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2663
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2663
                  endLoopArgs_2663:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode663)
                    jmp Lcont663
                  emptyA663:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty663
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop663:
                    cmp rax, rcx
                    je emptyA_end663
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop663
                  bothEmpty663:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode663)
                    jmp Lcont663
                  emptyA_end663:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode663)
                    jmp Lcont663
                  Lcode663:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 2                         ;;;cmp rbx numOfArgs
                    jge shrink663                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 32                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing663
                  shrink663:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 1                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink663:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink663
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink663
                  endLoopShrink663:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 32                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 2            ;;;newN= numArgs
                  doNothing663:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure665
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic665
                  notClosure665:
                    ;;;complete with segmentation fault
                  endApplic665:
                    leave
                    ret
                  Lcont663:
                    leave
                    ret
                  Lcont609:
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure606
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic606
                  notClosure606:
                    ;;;complete with segmentation fault
                  endApplic606:
                    leave
                    ret
                  Lcont604:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure596
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic596
                  notClosure596:
                    ;;;complete with segmentation fault
                  endApplic596:
                                                 define_lable594: 
                                                 mov qword [fvar_tbl +312], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +176]
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA675				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2675:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2675			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2675
                  endLoop_2675:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2675:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2675
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2675
                  endLoopArgs_2675:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode675)
                    jmp Lcont675
                  emptyA675:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty675
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop675:
                    cmp rax, rcx
                    je emptyA_end675
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop675
                  bothEmpty675:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode675)
                    jmp Lcont675
                  emptyA_end675:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode675)
                    jmp Lcont675
                    MAKE_CLOSURE (rbx, rax, Lcode675)
                    jmp Lcont675
                  Lcode675:
                    push rbp
                    mov rbp, rsp
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA677				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2677:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2677			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2677
                  endLoop_2677:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2677:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2677
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2677
                  endLoopArgs_2677:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode677)
                    jmp Lcont677
                  emptyA677:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty677
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop677:
                    cmp rax, rcx
                    je emptyA_end677
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop677
                  bothEmpty677:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode677)
                    jmp Lcont677
                  emptyA_end677:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode677)
                    jmp Lcont677
                    MAKE_CLOSURE (rbx, rax, Lcode677)
                    jmp Lcont677
                  Lcode677:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +41
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure679
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic679
                  notClosure679:
                    ;;;complete with segmentation fault
                  endApplic679:
                    leave
                    ret
                  Lcont677:
                    leave
                    ret
                  Lcont675:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure672
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic672
                  notClosure672:
                    ;;;complete with segmentation fault
                  endApplic672:
                                                 define_lable670: 
                                                 mov qword [fvar_tbl +320], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +152]
                                       push rax 
                                       mov rax, [fvar_tbl +168]
                                       push rax 
                                       mov rax, [fvar_tbl +72]
                                       push rax 
                                       mov rax, [fvar_tbl +80]
                                       push rax 
                    push 4
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA691				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2691:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2691			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2691
                  endLoop_2691:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2691:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2691
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2691
                  endLoopArgs_2691:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode691)
                    jmp Lcont691
                  emptyA691:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty691
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop691:
                    cmp rax, rcx
                    je emptyA_end691
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop691
                  bothEmpty691:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode691)
                    jmp Lcont691
                  emptyA_end691:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode691)
                    jmp Lcont691
                    MAKE_CLOSURE (rbx, rax, Lcode691)
                    jmp Lcont691
                  Lcode691:
                    push rbp
                    mov rbp, rsp
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA693				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2693:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2693			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2693
                  endLoop_2693:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2693:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2693
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2693
                  endLoopArgs_2693:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode693)
                    jmp Lcont693
                  emptyA693:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty693
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop693:
                    cmp rax, rcx
                    je emptyA_end693
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop693
                  bothEmpty693:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode693)
                    jmp Lcont693
                  emptyA_end693:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode693)
                    jmp Lcont693
                    MAKE_CLOSURE (rbx, rax, Lcode693)
                    jmp Lcont693
                  Lcode693:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +23
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA698				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2698:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2698			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2698
                  endLoop_2698:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2698:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2698
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2698
                  endLoopArgs_2698:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode698)
                    jmp Lcont698
                  emptyA698:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty698
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop698:
                    cmp rax, rcx
                    je emptyA_end698
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop698
                  bothEmpty698:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode698)
                    jmp Lcont698
                  emptyA_end698:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode698)
                    jmp Lcont698
                    MAKE_CLOSURE (rbx, rax, Lcode698)
                    jmp Lcont698
                  Lcode698:
                    push rbp
                    mov rbp, rsp
                    
mov rax, qword [rbp + 8*(4 + 0)]
                                 MALLOC rcx, 8
                                 mov [rcx], rax
                                 mov rax, rcx 
                                                         mov qword [rbp + 8*(4 + 0)], rax 
                                                         mov rax, SOB_VOID_ADDRESS

mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA709				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2709:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2709			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2709
                  endLoop_2709:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 4				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2709:
                    cmp	rcx, 3				        ;;; envSize-1 parameter 
                    je endLoopArgs_2709
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2709
                  endLoopArgs_2709:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode709)
                    jmp Lcont709
                  emptyA709:
                    mov	rcx, 3				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty709
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop709:
                    cmp rax, rcx
                    je emptyA_end709
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop709
                  bothEmpty709:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode709)
                    jmp Lcont709
                  emptyA_end709:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode709)
                    jmp Lcont709
                    MAKE_CLOSURE (rbx, rax, Lcode709)
                    jmp Lcont709
                  Lcode709:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +41
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*2] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure731
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic731
                  notClosure731:
                    ;;;complete with segmentation fault
                  endApplic731: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse710 
                                            mov rax, qword [rbp + 8*(4 + 1)] 
                                            jmp Lexit710 
                                            Lelse710: 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*2] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure717
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic717
                  notClosure717:
                    ;;;complete with segmentation fault
                  endApplic717:
                                       push rax 
                    push 2
                    mov rax, [fvar_tbl +200]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure714
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic714
                  notClosure714:
                    ;;;complete with segmentation fault
                  endApplic714:
                                       push rax 
                                        
                                       mov rax, const_tbl +32
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*2] 
                                                       mov rax, qword [rax + 8*3]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure723
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic723
                  notClosure723:
                    ;;;complete with segmentation fault
                  endApplic723:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure712
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic712
                  notClosure712:
                    ;;;complete with segmentation fault
                  endApplic712: 
                                            Lexit710:
                    leave
                    ret
                  Lcont709: 
                                     push rax 
                                     mov rax, qword [rbp + 8*(4 + 0)] 
                                     pop qword [rax] 
                                     mov rax, SOB_VOID_ADDRESS
 
                                       mov rax, const_tbl +1
                                       push rax 
                                        
                                       mov rax, const_tbl +32
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure742
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic742
                  notClosure742:
                    ;;;complete with segmentation fault
                  endApplic742:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*3]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure739
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic739
                  notClosure739:
                    ;;;complete with segmentation fault
                  endApplic739:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*(4 + 0)] 
                                  mov rax, qword [rax]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure736
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic736
                  notClosure736:
                    ;;;complete with segmentation fault
                  endApplic736:
                    leave
                    ret
                  Lcont698:
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure695
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic695
                  notClosure695:
                    ;;;complete with segmentation fault
                  endApplic695:
                    leave
                    ret
                  Lcont693:
                    leave
                    ret
                  Lcont691:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure685
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic685
                  notClosure685:
                    ;;;complete with segmentation fault
                  endApplic685:
                                                 define_lable683: 
                                                 mov qword [fvar_tbl +328], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, [fvar_tbl +112]
                                       push rax 
                                       mov rax, [fvar_tbl +192]
                                       push rax 
                                       mov rax, [fvar_tbl +184]
                                       push rax 
                                       mov rax, [fvar_tbl +128]
                                       push rax 
                                       mov rax, [fvar_tbl +48]
                                       push rax 
                                       mov rax, [fvar_tbl +40]
                                       push rax 
                                       mov rax, [fvar_tbl +24]
                                       push rax 
                                       mov rax, [fvar_tbl +8]
                                       push rax 
                                       mov rax, [fvar_tbl +16]
                                       push rax 
                                       mov rax, [fvar_tbl +328]
                                       push rax 
                                       mov rax, [fvar_tbl +176]
                                       push rax 
                    push 11
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA763				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2763:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2763			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2763
                  endLoop_2763:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2763:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2763
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2763
                  endLoopArgs_2763:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode763)
                    jmp Lcont763
                  emptyA763:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty763
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop763:
                    cmp rax, rcx
                    je emptyA_end763
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop763
                  bothEmpty763:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode763)
                    jmp Lcont763
                  emptyA_end763:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode763)
                    jmp Lcont763
                    MAKE_CLOSURE (rbx, rax, Lcode763)
                    jmp Lcont763
                  Lcode763:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, const_tbl +23
                                       push rax 
                    push 1
                    mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA768				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2768:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2768			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2768
                  endLoop_2768:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2768:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2768
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2768
                  endLoopArgs_2768:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode768)
                    jmp Lcont768
                  emptyA768:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty768
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop768:
                    cmp rax, rcx
                    je emptyA_end768
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop768
                  bothEmpty768:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode768)
                    jmp Lcont768
                  emptyA_end768:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode768)
                    jmp Lcont768
                    MAKE_CLOSURE (rbx, rax, Lcode768)
                    jmp Lcont768
                  Lcode768:
                    push rbp
                    mov rbp, rsp
                    
mov rax, qword [rbp + 8*(4 + 0)]
                                 MALLOC rcx, 8
                                 mov [rcx], rax
                                 mov rax, rcx 
                                                         mov qword [rbp + 8*(4 + 0)], rax 
                                                         mov rax, SOB_VOID_ADDRESS

mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA779				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2779:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2779			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2779
                  endLoop_2779:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 3				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2779:
                    cmp	rcx, 2				        ;;; envSize-1 parameter 
                    je endLoopArgs_2779
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2779
                  endLoopArgs_2779:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode779)
                    jmp Lcont779
                  emptyA779:
                    mov	rcx, 2				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty779
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop779:
                    cmp rax, rcx
                    je emptyA_end779
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop779
                  bothEmpty779:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode779)
                    jmp Lcont779
                  emptyA_end779:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode779)
                    jmp Lcont779
                    MAKE_CLOSURE (rbx, rax, Lcode779)
                    jmp Lcont779
                  Lcode779:
                    push rbp
                    mov rbp, rsp
                    
 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure801
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic801
                  notClosure801:
                    ;;;complete with segmentation fault
                  endApplic801: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse787 
                                             
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*2]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure797
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic797
                  notClosure797:
                    ;;;complete with segmentation fault
                  endApplic797: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse789 
                                             
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure792
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic792
                  notClosure792:
                    ;;;complete with segmentation fault
                  endApplic792: 
                                            jmp Lexit789 
                                            Lelse789: 
                                            mov rax, const_tbl +4 
                                            Lexit789: 
                                            jmp Lexit787 
                                            Lelse787: 
                                            mov rax, const_tbl +4 
                                            Lexit787: 
                                                cmp rax, SOB_FALSE_ADDRESS 
                                                jne Lexit781
 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*3]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure818
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic818
                  notClosure818:
                    ;;;complete with segmentation fault
                  endApplic818: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse804 
                                             
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*3]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure814
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic814
                  notClosure814:
                    ;;;complete with segmentation fault
                  endApplic814: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse806 
                                             
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure809
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic809
                  notClosure809:
                    ;;;complete with segmentation fault
                  endApplic809: 
                                            jmp Lexit806 
                                            Lelse806: 
                                            mov rax, const_tbl +4 
                                            Lexit806: 
                                            jmp Lexit804 
                                            Lelse804: 
                                            mov rax, const_tbl +4 
                                            Lexit804: 
                                                cmp rax, SOB_FALSE_ADDRESS 
                                                jne Lexit781
 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*4]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure856
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic856
                  notClosure856:
                    ;;;complete with segmentation fault
                  endApplic856: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse821 
                                             
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*4]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure852
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic852
                  notClosure852:
                    ;;;complete with segmentation fault
                  endApplic852: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse823 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*8]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure842
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic842
                  notClosure842:
                    ;;;complete with segmentation fault
                  endApplic842:
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*8]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure846
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic846
                  notClosure846:
                    ;;;complete with segmentation fault
                  endApplic846:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure840
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic840
                  notClosure840:
                    ;;;complete with segmentation fault
                  endApplic840: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse825 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*9]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure830
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic830
                  notClosure830:
                    ;;;complete with segmentation fault
                  endApplic830:
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*9]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure834
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic834
                  notClosure834:
                    ;;;complete with segmentation fault
                  endApplic834:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure828
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic828
                  notClosure828:
                    ;;;complete with segmentation fault
                  endApplic828: 
                                            jmp Lexit825 
                                            Lelse825: 
                                            mov rax, const_tbl +4 
                                            Lexit825: 
                                            jmp Lexit823 
                                            Lelse823: 
                                            mov rax, const_tbl +4 
                                            Lexit823: 
                                            jmp Lexit821 
                                            Lelse821: 
                                            mov rax, const_tbl +4 
                                            Lexit821: 
                                                cmp rax, SOB_FALSE_ADDRESS 
                                                jne Lexit781
 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*5]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure879
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic879
                  notClosure879:
                    ;;;complete with segmentation fault
                  endApplic879: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse859 
                                             
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*5]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure875
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic875
                  notClosure875:
                    ;;;complete with segmentation fault
                  endApplic875: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse861 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*10]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure866
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic866
                  notClosure866:
                    ;;;complete with segmentation fault
                  endApplic866:
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*10]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure870
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic870
                  notClosure870:
                    ;;;complete with segmentation fault
                  endApplic870:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*0]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure864
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic864
                  notClosure864:
                    ;;;complete with segmentation fault
                  endApplic864: 
                                            jmp Lexit861 
                                            Lelse861: 
                                            mov rax, const_tbl +4 
                                            Lexit861: 
                                            jmp Lexit859 
                                            Lelse859: 
                                            mov rax, const_tbl +4 
                                            Lexit859: 
                                                cmp rax, SOB_FALSE_ADDRESS 
                                                jne Lexit781
 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*6]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure903
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic903
                  notClosure903:
                    ;;;complete with segmentation fault
                  endApplic903: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse882 
                                             
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*6]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure899
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic899
                  notClosure899:
                    ;;;complete with segmentation fault
                  endApplic899: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse884 
                                             
                                        
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure889
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic889
                  notClosure889:
                    ;;;complete with segmentation fault
                  endApplic889:
                                       push rax 
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*1]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure893
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic893
                  notClosure893:
                    ;;;complete with segmentation fault
                  endApplic893:
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*0] 
                                                       mov rax, qword [rax + 8*0] 
                                  mov rax, qword [rax]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure887
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic887
                  notClosure887:
                    ;;;complete with segmentation fault
                  endApplic887: 
                                            jmp Lexit884 
                                            Lelse884: 
                                            mov rax, const_tbl +4 
                                            Lexit884: 
                                            jmp Lexit882 
                                            Lelse882: 
                                            mov rax, const_tbl +4 
                                            Lexit882: 
                                                cmp rax, SOB_FALSE_ADDRESS 
                                                jne Lexit781 
                   
                                       mov rax, qword [rbp + 8*(4 + 1)]
                                       push rax 
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 2
                    mov rax, qword [rbp + 8*2] 
                                                       mov rax, qword [rax + 8*1] 
                                                       mov rax, qword [rax + 8*7]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure783
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic783
                  notClosure783:
                    ;;;complete with segmentation fault
                  endApplic783: 
                  Lexit781:
                    leave
                    ret
                  Lcont779: 
                                     push rax 
                                     mov rax, qword [rbp + 8*(4 + 0)] 
                                     pop qword [rax] 
                                     mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8*(4 + 0)] 
                                  mov rax, qword [rax]
                    leave
                    ret
                  Lcont768:
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure765
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 5
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic765
                  notClosure765:
                    ;;;complete with segmentation fault
                  endApplic765:
                    leave
                    ret
                  Lcont763:
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure750
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic750
                  notClosure750:
                    ;;;complete with segmentation fault
                  endApplic750:
                                                 define_lable748: 
                                                 mov qword [fvar_tbl +336], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA910				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2910:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2910			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2910
                  endLoop_2910:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2910:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2910
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2910
                  endLoopArgs_2910:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode910)
                    jmp Lcont910
                  emptyA910:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty910
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop910:
                    cmp rax, rcx
                    je emptyA_end910
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop910
                  bothEmpty910:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode910)
                    jmp Lcont910
                  emptyA_end910:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode910)
                    jmp Lcont910
                    MAKE_CLOSURE (rbx, rax, Lcode910)
                    jmp Lcont910
                  Lcode910:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, [fvar_tbl +32]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure931
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic931
                  notClosure931:
                    ;;;complete with segmentation fault
                  endApplic931: 
                                            cmp rax, SOB_FALSE_ADDRESS 
                                            je Lelse911 
                                            mov rax, const_tbl +1 
                                            jmp Lexit911 
                                            Lelse911: 
                                             
                                        
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, [fvar_tbl +184]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure917
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic917
                  notClosure917:
                    ;;;complete with segmentation fault
                  endApplic917:
                                       push rax 
                    push 1
                    mov rax, [fvar_tbl +272]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure915
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic915
                  notClosure915:
                    ;;;complete with segmentation fault
                  endApplic915:
                                       push rax 
                                        
                                        
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                    push 1
                    mov rax, [fvar_tbl +192]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure924
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic924
                  notClosure924:
                    ;;;complete with segmentation fault
                  endApplic924:
                                       push rax 
                    push 1
                    mov rax, [fvar_tbl +344]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure922
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic922
                  notClosure922:
                    ;;;complete with segmentation fault
                  endApplic922:
                                       push rax 
                    push 2
                    mov rax, [fvar_tbl +264]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure913
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic913
                  notClosure913:
                    ;;;complete with segmentation fault
                  endApplic913: 
                                            Lexit911:
                    leave
                    ret
                  Lcont910:
                                                 define_lable908: 
                                                 mov qword [fvar_tbl +344], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA936				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2936:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2936			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2936
                  endLoop_2936:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 1				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2936:
                    cmp	rcx, 0				        ;;; envSize-1 parameter 
                    je endLoopArgs_2936
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2936
                  endLoopArgs_2936:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode936)
                    jmp Lcont936
                  emptyA936:
                    mov	rcx, 0				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty936
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop936:
                    cmp rax, rcx
                    je emptyA_end936
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop936
                  bothEmpty936:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode936)
                    jmp Lcont936
                  emptyA_end936:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode936)
                    jmp Lcont936
                    MAKE_CLOSURE (rbx, rax, Lcode936)
                    jmp Lcont936
                  Lcode936:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                        mov	rcx, qword [rbp + 24]		;;;rcx = n
                    cmp	rcx, 0
                    je  emptyA941				        ;;;n==0? yes- no malloc to A[] needed		        
                    mov rdx, rcx
                    shl rdx, 3				            ;;;rdx = 8*n
                    MALLOC rbx, rdx           ;;;rbx -> a new memory [8*n]  
                    mov rax, rbp
                    add rax, 32     				  ;;;rax -> A[0]
                    mov rdx, 0			        	;;;rdx = 0 (counter)
                  Loop_2941:                   ;;; rax = pointer to A[i], rbx = pointer to new memory, rcx = n, rdx = i
                    cmp	rdx, rcx				      ;;;i==n? yes - finished
                    je	endLoop_2941			
                    push rax
                    mov	rax, [rax]	      		;;;rax = A[i]
                    mov [rbx], rax	      		;;;Mem[i] = A[i]
                    add	rbx, 8				        ;;;rbx -> Mem[i+1]
                    pop	rax				
                    add	rax,8		          		;;;rax -> A[i+1]
                    inc rdx					          ;;;i++
                    jmp Loop_2941
                  endLoop_2941:
                    shl	rcx, 3
                    sub	rbx, rcx				      ;;; rbx->Mem[0]
                    mov	rcx, 2				        ;;; env_size- d
                    shl rcx, 3  	          	;;; rcx = 8*env_size
                    MALLOC rdx, rcx			      ;;; rdx -> new_env[0]	
                    mov [rdx], rbx			      ;;; new_env[0] = pointer to A[]
                    mov rbx, qword [rbp+16]	  ;;; rbx -> env[0]
                    mov rcx,0				          ;;; i=0 , rcx is counter
                  LoopArgs_2941:
                    cmp	rcx, 1				        ;;; envSize-1 parameter 
                    je endLoopArgs_2941
                    add rdx, 8				        ;;; rdx -> new_env[i+1]
                    push rbx
                    mov rbx, [rbx]
                    mov [rdx], rbx
                    pop rbx
                    add rbx, 8				        ;;; rbx -> env[i]
                    inc rcx
                    jmp LoopArgs_2941
                  endLoopArgs_2941:
                    shl rcx, 3
                    sub rdx, rcx				      ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode941)
                    jmp Lcont941
                  emptyA941:
                    mov	rcx, 1				        ;;; envSize-1
                    cmp rcx, 0                ;;; both sizes 0
                    je bothEmpty941
                    push rcx
                    shl rcx, 3			          ;;; rcx = 8*env_size
                    MALLOC rbx, rcx			      ;;; rbx -> new_env[0]
                    mov rdx, qword[rbp+16]	  ;;; rdx -> env[0]
                    pop rcx					          ;;; rcx = env_size
                    mov rax,0				          ;;; rax = 0 (counter)
                  emptyA_loop941:
                    cmp rax, rcx
                    je emptyA_end941
                    push rdx
                    mov rdx, [rdx]
                    mov [rbx],rdx			      ;;; new_env[i] = env[i]
                    pop rdx
                    add	rdx, 8				        ;;; rdx -> new_env[i+1]
                    add rbx, 8				        ;;; rbx -> env[i+1]
                    inc rax					          ;;; i++
                    jmp emptyA_loop941
                  bothEmpty941:
                    mov rbx, SOB_NIL_ADDRESS
                    MAKE_CLOSURE (rax, rbx, Lcode941)
                    jmp Lcont941
                  emptyA_end941:
                    shl rcx, 3
                    sub rdx,rcx				        ;;; rdx -> new_env[0]
                    MAKE_CLOSURE (rax, rdx, Lcode941)
                    jmp Lcont941
                  Lcode941:
                    mov rbx, [rsp + 16]                 ;;;rbx = n
                    cmp rbx, 1                         ;;;cmp rbx numOfArgs
                    jge shrink941                        ;;;n < numOfArgs
                    mov rsi, rsp                        ;;;rdi - destination
                    mov rcx, rsp                        ;;;rsi - source
                    sub rcx, 8
                    mov rdi, rcx
                    mov rdx, 24                         ;;;bytes = 24+(numArgs-1)*8                        
                    push 0
                    call memmove                        ;;;rax - destination address
                    mov rax, [rsp+16]
                    shl rax, 3
                    add rax, 24
                    add rax, rsp
                    mov qword [rax], SOB_NIL_ADDRESS    ;;;optArg = Nill
                    inc rbx
                    mov [rsp + 16], rbx
                    jmp doNothing941
                  shrink941:                             ;;;n >= numOfArgs
                    
                    mov rcx, rbx                        ;;;rcx = n
                    sub rcx, 0                         ;;;rcx = n - numOfArgs --> we need to shrink in to a list
                    mov rbx, [rsp + 16]
                    shl rbx, 3
                    add rbx, 16
                    add rbx, rsp                       ;;;rbx = rsp + allframe
                    mov rdi, [rbx]                     ;;;rdi = args[n]		
                    MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)                           
                    mov rdx, rcx                          ;;;rdx = counter
                    dec rdx
                  loopShrink941:  
                    cmp rdx, 0                        ;;; rcx = opt_args.size
                    je endLoopShrink941
                    sub rbx, 8
                    mov rdi, [rbx]
                    mov rsi, rax
                    MAKE_PAIR(rax, rdi, rsi)            ;;;Pair(arg[n+i], PrevPair)
                    dec rdx                             ;;;counter--
                    jmp loopShrink941
                  endLoopShrink941:                           
                    mov rbx, rax                        ;;;rbx -> array[0]
                    mov rsi, rsp
                    dec rcx
                    shl rcx, 3
                    mov rdx, rcx
                    add rdx, rsp
                    mov rdi, rdx
                    mov rdx, 24                         ;;; rdx = 24 + num_args*8
                    push rbx
                    call memmove
                    pop rbx
                    mov rax, rbp
                    sub rax, 8
                    add rsp, rcx
                    add rdx, rsp
                    mov [rdx], rbx                      ;;;frame[0] = malloc
                    mov qword [rsp + 16], 1            ;;;newN= numArgs
                  doNothing941:
                    push rbp
                    mov rbp, rsp
                     
                                       mov rax, qword [rbp + 8*(4 + 0)]
                                       push rax 
                                       mov rax, [fvar_tbl +344]
                                       push rax 
                    push 2
                    mov rax, [fvar_tbl +224]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure943
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic943
                  notClosure943:
                    ;;;complete with segmentation fault
                  endApplic943:
                    leave
                    ret
                  Lcont941:
                                       push rax 
                    push 2
                    mov rax, [fvar_tbl +232]
                    mov rdi, rax
                    mov sil, byte [rdi]
                    cmp sil, T_CLOSURE
                    jne notClosure938
                    mov rbx, qword [rdi + 1]                ;;;rbx = ext_env
                    push rbx
                    push qword [rbp + 8]                ;;; old ret addr
                    push qword [rbp]
                    SHIFT_FRAME 6
                    mov rbx, qword [rdi + 9]                ;;;rbx = Lcode
                    jmp rbx
                    jmp endApplic938
                  notClosure938:
                    ;;;complete with segmentation fault
                  endApplic938:
                    leave
                    ret
                  Lcont936:
                                                 define_lable934: 
                                                 mov qword [fvar_tbl +352], rax 
                                                 mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

 
                                       mov rax, const_tbl +311
                                       push rax 
                    push 1
                    mov rax, [fvar_tbl +352]
                    mov sil, byte [rax]
                    cmp sil, T_CLOSURE
                    jne notClosure949
                    mov rbx, qword [rax + 1]                ;;;rbx = ext_env
                    push rbx
                    mov rbx, qword [rax + 9]                ;;;rbx = Lcode
                    call rbx
                    mov rbx, [rsp + 8]                      ;;; n 
                    add rbx, 2
                    shl rbx, 3
                    add rsp, rbx
                    jmp endApplic949
                  notClosure949:
                    ;;;complete with segmentation fault
                  endApplic949:
	call write_sob_if_not_void

	mov rax, 0
	add rsp, 4*8
	pop rbp
	ret

is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

    cmp rcx, 0
    je .end
	
.loop:
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    loop .loop
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

car_asm:
    push rbp
    mov rbp, rsp

    mov rax, PVAR(0)
    CAR rax, rax

    leave
    ret

cdr_asm:
    push rbp
    mov rbp, rsp

    mov rax, PVAR(0)
    CDR rax, rax

    leave
    ret

cons_asm:
    push rbp
    mov rbp, rsp

    mov rcx, PVAR(0)
    mov rbx, PVAR(1)
    MAKE_PAIR (rax, rcx, rbx)

    leave
    ret

set_car_asm:
    push rbp
    mov rbp, rsp

    mov rax, PVAR(0)
    mov rbx, PVAR(1)
    mov qword [rax + TYPE_SIZE], rbx
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

set_cdr_asm:
    push rbp
    mov rbp, rsp

    mov rax, PVAR(0)
    mov rbx, PVAR(1)
    mov qword [rax + TYPE_SIZE + WORD_SIZE], rbx
    mov rax, SOB_VOID_ADDRESS

    leave
    ret


apply_asm:
    pop rbx              	;; ret address
    pop rcx              	;; env
    pop r13              	;; params num
    pop rcx              	;; first-param f
    sub r13, 2           	;; params = params - f - optArg
    mov r15, r13
    shl r15, 3
    add r15, rsp
    mov rax, [r15]	  	;; rax -> optArgs list

  apply_loop:
    cmp rax, SOB_NIL_ADDRESS
    je end_apply_loop
    CAR rdx, rax		;; rbx = first element of the list
    CDR rax, rax		;; rax = rest of the list
    mov qword [r15], rdx  
    mov rsi, rsp
    mov rdi, rsp
    sub rdi, 8       
    inc r13
    mov rdx, r13      
    shl rdx, 3
    push 0
    push rax
    push rcx
    call memmove        	;; shift all frame 8 bit down
    pop rcx
    pop rax
    jmp apply_loop

  end_apply_loop:
    mov rsi, rsp       
    mov rdi, rsp
    add rdi, 8
    mov rdx, r13
    shl rdx, 3
    push rcx
    call memmove        	;; shift all frame 0 bit up (SOB_NIL_ADDRESS remained at the top of the frame)
    pop rcx
    add rsp, 8

    push r13              	;; new params
    push qword [rcx + 1]  	;; new env = closure f env
    push rbx              	;; ret address
    mov rax, [rcx + 9]    	;; closure f code
    jmp rax




